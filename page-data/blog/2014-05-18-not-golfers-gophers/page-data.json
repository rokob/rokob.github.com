{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2014-05-18-not-golfers-gophers/","result":{"data":{"markdownRemark":{"html":"<p>I was doing some language exploration as I am toying with the idea of getting some backend\nservices up and running, and I have some constraints that Ruby does not meet. I kept hearing\npeople mention Go, and my only vague notion about it was that it was like Erlang but not\nas mature, so I have been putting off really looking into it. Well that changed, I went through\nthe Go tour and have been playing around with it a bit, and I have to say I am really impressed.</p>\n<h2>Channels vs Actors</h2>\n<p>The actor model in Erlang encourages you to code in a certain style. Basically, you write\nsingle purpose entities with a minimal amount of state, that operate using mostly pure functions.\nThe only interactions with the world outside of an actor are through message passing, and those\nmessages are typically tagged tuples. Each actor has a mailbox for getting messages which it typically\nprocesses in a FIFO way, but you can also do selective receives by pattern matching on the messages\nin your inbox. In this way, when you want to communicate to another actor, you need a reference\nto their process identifier (PID), that you can use to send messages to. You usually get this\nreference passed to you in a message. For instance, here is a raw version of a common pattern in\nnon-OTP code for the main loop of an Erlang actor:</p>\n<div class=\"gatsby-highlight\" data-language=\"erlang\"><pre class=\"language-erlang\"><code class=\"language-erlang\"><span class=\"token comment\">% some_guy.erl</span>\n<span class=\"token function\">live</span><span class=\"token punctuation\">(</span><span class=\"token variable\">State</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span>\n  <span class=\"token keyword\">receive</span>\n    <span class=\"token punctuation\">{</span><span class=\"token variable\">From</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token atom\">handshake</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">Person</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span>\n      <span class=\"token variable\">NewState</span> <span class=\"token operator\">=</span> <span class=\"token function\">shake_hands</span><span class=\"token punctuation\">(</span><span class=\"token variable\">State</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">Person</span><span class=\"token punctuation\">)</span>\n      <span class=\"token variable\">From</span> <span class=\"token operator\">!</span> <span class=\"token punctuation\">{</span><span class=\"token function\">self</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token atom\">ok</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function\">live</span><span class=\"token punctuation\">(</span><span class=\"token variable\">NewState</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span><span class=\"token variable\">From</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token atom\">punch</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">Person</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span>\n      <span class=\"token variable\">NewState</span> <span class=\"token operator\">=</span> <span class=\"token function\">get_punched</span><span class=\"token punctuation\">(</span><span class=\"token variable\">State</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">Person</span><span class=\"token punctuation\">)</span>\n      <span class=\"token variable\">From</span> <span class=\"token operator\">!</span> <span class=\"token punctuation\">{</span><span class=\"token function\">self</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token atom\">ok</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function\">live</span><span class=\"token punctuation\">(</span><span class=\"token variable\">NewState</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token atom\">terminate</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span>\n      <span class=\"token atom\">ok</span>\n  <span class=\"token keyword\">end</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>This guy's life is pretty boring, he knows how to shake hands, get punched, and die. Here, we do\na selective receive on the mailbox, and the loop will only pull messages out of the mailbox that\nare of the form <code class=\"language-text\">{SomePID, {Action, Varible}}</code> where <code class=\"language-text\">Action</code> is in a small set of known atoms.\nHe also responds to <code class=\"language-text\">terminate</code> which stops him looping. The way you would message this guy\nfrom another actor would look like</p>\n<div class=\"gatsby-highlight\" data-language=\"erlang\"><pre class=\"language-erlang\"><code class=\"language-erlang\"><span class=\"token variable\">SomeGuyPid</span> <span class=\"token operator\">=</span> <span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token atom\">some_guy</span><span class=\"token punctuation\">,</span> <span class=\"token atom\">live</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n<span class=\"token variable\">SomeGuyPid</span> <span class=\"token operator\">!</span> <span class=\"token punctuation\">{</span><span class=\"token function\">self</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token atom\">handshake</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Me\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>In Erlang, <code class=\"language-text\">self()</code> returns your own PID, this allows us to send messages to others and get\nreplies back without them actually knowing who we are. This allows actors to be highly\ndecoupled and it makes it really easy to keep them single purpose. There needs to be some actor\nat the top who spawns some processes, and maybe has a lookup table from names to PIDs, but\nmost of the actors you write simply receive a message with enough context to know who to\nrespond to. In reality you use OTP to build trees of communicating processes, and wrap these\nbare message sends in APIs, but the underlying idea is the same. Actors have a mailbox with\nan address (PID), and you can stuff their mailbox by sending a message to that address. It is\nthen up to them to choose what and when to pull out of their mailbox.</p>\n<p>Go does not present these same primatives. Instead, Go has a type known as a <code class=\"language-text\">Channel</code>. A\nchannel can be send-only, receive-only, or bidirectional. Any number of processes can\nwrite to or read from a channel as long as they have a reference to it. If we want to reimplement\nthe same boring guy as above in Go, it might look something like (pardon my ignorance, I wrote\nhello world in Go yesterday):</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// some_guy.go</span>\n<span class=\"token keyword\">type</span> InMessage <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">inMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> OutMessage <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">outMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Request <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  From <span class=\"token keyword\">chan</span> OutMessage\n  Action <span class=\"token builtin\">string</span>\n  Person <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Atom <span class=\"token builtin\">string</span>\n<span class=\"token keyword\">type</span> Response <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  From <span class=\"token keyword\">chan</span>\n  Status Atom\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>Atom<span class=\"token punctuation\">)</span> <span class=\"token function\">outMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>Response<span class=\"token punctuation\">)</span> <span class=\"token function\">outMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>Atom<span class=\"token punctuation\">)</span> <span class=\"token function\">inMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>Request<span class=\"token punctuation\">)</span> <span class=\"token function\">inMessageType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Live</span><span class=\"token punctuation\">(</span>state <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> ch <span class=\"token keyword\">chan</span> InMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  raw_msg <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch\n  <span class=\"token keyword\">switch</span> msg <span class=\"token operator\">:=</span> raw_msg<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> Request<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">switch</span> msg<span class=\"token punctuation\">.</span>Action <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token char\">'handshake'</span><span class=\"token punctuation\">:</span>\n      new_state <span class=\"token operator\">=</span> <span class=\"token function\">shake_hands</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">)</span>\n      msg<span class=\"token punctuation\">.</span>From <span class=\"token operator\">&lt;-</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">{</span>ch<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ok\"</span><span class=\"token punctuation\">}</span>\n      <span class=\"token function\">Live</span><span class=\"token punctuation\">(</span>new_state<span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">case</span> <span class=\"token char\">'punch'</span><span class=\"token punctuation\">:</span>\n      new_state <span class=\"token operator\">=</span> <span class=\"token function\">get_punched</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">)</span>\n      msg<span class=\"token punctuation\">.</span>From <span class=\"token operator\">&lt;-</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">{</span>ch<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ok\"</span><span class=\"token punctuation\">}</span>\n      <span class=\"token function\">Live</span><span class=\"token punctuation\">(</span>new_state<span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">case</span> Atom<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> msg <span class=\"token operator\">==</span> <span class=\"token string\">\"terminate\"</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// \"ok\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Although some of the trickeration I had to go through there with something like an\nalgebraic data type (ADT) was primiarly because of the constraints imposed by directly\ntranslating from Erlang. I have found that the type of structures you use as communcation\nprimatives in an untyped language are drastically different than what you would choose\nto use in a typed language. For instance, it is common to use a heterogeneous array\nin languages like Python to repreesnt multiple return values, and this makes sense\nbecause that is how the language allows you to work. Clearly you wouldn't do this\nin a language like Haskell which does not allow heterogeneous lists, instead you\nwould typically use an ADT. In Erlang, you often use tuples, usually with type tags,\nas the communication protocol, because of the nice pattern matching facilities, the\nlow overhead of these objects, and the complete lack of static types. In Go, we have\ntypes, but not ADTs (well not naturally anyway), but we do have interfaces. Typically\nthis communication would be done over a more natural set of channels with a more\nclearly defined interface for the objects being passed around.</p>\n<p>I can imagine building channels in Erlang and Actors in Go using the set of primatives\nthat are offered, so I don't think they should really be seen as competing technologies\nin that sense. However, Go encourages the use of typed channels for communication.\nI think this is great. I think channels are more general and allow the type of flexibility\nthat you usually want. If you want a channel that only one goroutine uses then you can\ndo that really easily, you just only pass the reference to that function. But the ability\nto build more complex communication networks out of channels is super interesting.\nAlso having some notion of static types on those channels is nice only because of the\nflexibility of the type system in Go. Usually you have to jump through a lot of hoops\nwhen you are dealing with making outside data type safe, but it seems like Go makes\nan okay tradeoff here. My opinion on that is mostly grounded in my lack of experience\ndoing that everyday in a strong, statically typed language, it just feels like a ton\nof extra work with real, but sometimes marginal benefits.</p>\n<h2>Go oddities</h2>\n<p>So I like the language of Go, but it has some goofy parts too. The one that bugs\nme the most, is how it handles pointers, references, values, and interfaces. Okay,\nthat makes no sense I know, but here is the example (taken from part 55 of the Go tour):</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber 0\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token string\">\"math\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> Abser <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">float64</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a Abser\n    f <span class=\"token operator\">:=</span> <span class=\"token function\">MyFloat</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>math<span class=\"token punctuation\">.</span>Sqrt2<span class=\"token punctuation\">)</span>\n    v <span class=\"token operator\">:=</span> Vertex<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span>\n\n    a <span class=\"token operator\">=</span> f\n    a <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>v\n\n    <span class=\"token comment\">// a = v</span>\n    <span class=\"token comment\">// uncomment the line above => no compile</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">Abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// this compiles just fine</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">Abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> MyFloat <span class=\"token builtin\">float64</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>f MyFloat<span class=\"token punctuation\">)</span> <span class=\"token function\">Abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">float64</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> f <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">float64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>f<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">float64</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Vertex <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    X<span class=\"token punctuation\">,</span> Y <span class=\"token builtin\">float64</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">*</span>Vertex<span class=\"token punctuation\">)</span> <span class=\"token function\">Abs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">float64</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> math<span class=\"token punctuation\">.</span><span class=\"token function\">Sqrt</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>X<span class=\"token operator\">*</span>v<span class=\"token punctuation\">.</span>X <span class=\"token operator\">+</span> v<span class=\"token punctuation\">.</span>Y<span class=\"token operator\">*</span>v<span class=\"token punctuation\">.</span>Y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We are defining an interface called <code class=\"language-text\">Abser</code> which has one functio <code class=\"language-text\">Abs()</code> which returns a <code class=\"language-text\">float64</code>.\nAt the bottom we define two types and implement the interface for them. However, for one, <code class=\"language-text\">MyFloat</code>\nwe implement the interface with a value of the type, not a pointer. For the other, <code class=\"language-text\">Vertex</code>, we\nimplement the interface only for a pointer to that type. Okay, now here is the weird part,\nif you uncomment line 20, this will not compile. This is because you cannot assign a value of\ntype <code class=\"language-text\">Vertex</code> to a variable of the interface type <code class=\"language-text\">Abser</code> because there is no implementation for\n<code class=\"language-text\">Abs</code> on a value of type <code class=\"language-text\">Vertex</code>. Now this is perfectly reasonable, it could be that the implementation\nmutates the object and therefore only getting a copy via pass-by-value would not be the intended\nbehaviour. So Go makes the decision that because of that, there is no implementation for that type and\nrefuses to compile. However, the next line shows clearly that you can call <code class=\"language-text\">Abs</code> on a <code class=\"language-text\">Vertex</code> value.\nThis works just fine because the value is implicitly converted to a pointer. In many places, because\nGo allows you to use the same syntax when working with a pointer, reference, and value, it can be\nsomewhat confusing to know which one you've got. Most of the time it doesn't really matter, but\nthe fact that it does enforce some constraints on this is a bit weird. Basically, just because you\nsee the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> X <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">someFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> v SomeType\n  v<span class=\"token punctuation\">.</span><span class=\"token function\">someFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It does not imply that <code class=\"language-text\">v</code> actually implements the interface <code class=\"language-text\">X</code> which entirely flies in the face\nof duck typing intuition. It is only this edge case dealing with pointers and values that I know\nof where you can make this happen, but still it is not desireable.</p>\n<h2>Will I use it?</h2>\n<p>I really like the strong standard library, the channel based concurrency primatives, and\nthe static typing. There is also a nice library called <a href=\"http://www.goworker.org/\">goworker</a> which allows you\nto use Go to write workers for jobs using <a href=\"https://github.com/resque/resque\">Resque</a>. Basically, this means that in a Rails\napp, you can push work onto a Redis queue, then have a Go process pull the work off that queue, and\ndo whatever it needs to do to process that job. Now clearly, you can pick any two languages and\nany middle queueing system you want and make the same statement. However, the solid concurrency\nprimatives of Go, with a low memory footprint, combined with the fact that I am already preconstrained\nto be working in a Rails environment, makes this set-up highly appealing. I am currently writing\nbackground services in Ruby, which works and is a great language. But I think there are some services\nwhere having high concurrency and high performance will be paramount and I want to have the ability\nto handle those tasks sooner rather than later.</p>","frontmatter":{"title":"Not Golfers, Gophers","date":"18 May 2014","categories":"code","tags":["go","code","erlang"]},"timeToRead":7,"wordCount":{"words":1434},"fields":{"sha":"9a9b8cc9a846a5ab6c26cb187880f3092ad02345"},"parent":{"relativePath":"2014-05-18-not-golfers-gophers.md"}}},"pageContext":{"slug":"/blog/2014-05-18-not-golfers-gophers/"}},"staticQueryHashes":["3159585216","3192915761"],"slicesMap":{}}