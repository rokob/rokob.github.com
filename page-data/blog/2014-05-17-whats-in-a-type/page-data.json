{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2014-05-17-whats-in-a-type/","result":{"data":{"markdownRemark":{"html":"<h3>Disclaimer:</h3>\n<p>I need to put a giant disclaimer up front here about how I am not an expert in type theory. I read a lot of books and have written code in many different languages,\nboth professionally and in my spare time. I enjoy thinking about some of the underlying concepts in computer science, and I have sat in on quite a few graduate\ncourses in CS while I was doing my PhD in something that is not computer science. Therefore I may certainly make statements in this post that are strictly wrong from\na pure theoretical standpoint, although I certainly hope not. This post is mostly going to be about my experiences and where I currently stand on the subject of types in programming languages.</p>\n<h2>Object Oriented Type Systems</h2>\n<p>I think that object oriented programming can be a simple way of organizing your thoughts in code. It works well when you have a clear set of real-world objects\nwith a single purpose that generates their identity and relationships to one another, and you want to have a conversation with others without any code involved. Often\ntimes the decision to use an object oriented language comes from:</p>\n<ul>\n<li>Legacy</li>\n<li>Hiring concerns</li>\n<li>Previous experience</li>\n<li>Existence of domain experts</li>\n<li>Unwillingness to learn</li>\n<li>Lack of knowledge of alternatives</li>\n<li>Risk assessments</li>\n</ul>\n<p>I think that object oriented type systems breakdown when programming in the small and the large, but can be quite natural in the middle ground. One problem with this\nis that there is much pain upfront when prototyping, which leads to an okay state in the middle where you feel like your hard work has paid off, only to be followed by\nan eternal death spiral where you don't want to change course because of the debt you've already paid. This sunk cost colors your decision making and makes you put in\neven more work to keep your giant ball of <code class=\"language-text\">AbstractFactoryFactories</code> humming. You start to write code because of the language, to satisfy the type checker's opinion\nyou are forced to do unnatural things like forcing unrelated things to have a common super class. Eventually you start to use <code class=\"language-text\">void*</code> or <code class=\"language-text\">id</code> or <code class=\"language-text\">Object</code> to write\n\"generic\" functions and at that point you've lost.</p>\n<h3>Object Oriented Done Right</h3>\n<p>Fundamentally, OO is about single purpose objects that communicate via message passing. This has been lost over time with different implementations and interpretations\nof what being object oriented means. This usually happens with the interpretation of what \"everything is an object\" means. To me, that phrase means that every construct\nin your program has a set of messages that it understands. If you send it a message it understands, then it will do something. If you send it a message it doesn't\nunderstand, well the world might explode in firey exceptions, or it might try to interpret your message in another way by deferring to other objects that it knows about.\nThis is how the real world works, in some sense. The problem enters when you start to define what an object is by a static identifier rather than as a set of messages\nthat it knows how to handle. Erlang is an OO language with each process representing an object. If you send a message to an Erlang process, it will either act on it\nbecause it understands it, or it will tell you it has no idea what you are talking about. Conceptually this is what OO is about, it is just the implementations of these\nideas where people start to be led astray.</p>\n<p>Ruby is an overtly OO language, but it also fundamentally starts from the perspective of objects as actors that either respond to a message or don't. Erlang and Ruby\nhave in common that they are dynamically, strongly typed. I need to emphasize what I mean by strong because it is not a well-defined term. I will stick with the statement\nby Liskov \"whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function\".\nTranslate this roughly to mean that if an object only needs to be compatible with a function call, so for instance in Ruby this means that if you send a message to an\nobject, it simply needs to respond to that message in some way that does not throw an exception or otherwise corrupt the state of the running program. The type checking\nis done at runtime, so you only find out that things blow up when they actually blow up. But that being said, they do blow up if something is wrong. Static type checking\nis independent of type strength. In these so-called duck type languages, you code against what an object can do, not what it's name is. In this way, it is much more\nakin to the real world where you ask someone to do a job because they are capable, not because they have a particular title or pedigree (or wait...)</p>\n<h3>Object Oriented Done Wrong</h3>\n<p>There are OO languages with a more strict view on what a type is. C++, for instance, has a static, nominal type system. You must know at compile time exactly whether an\nobject is compatible with a function call, and you know this based on the declaration of the object. That is, the exact name of the object is what is important. Now,\nyou can say that this comes along with a set of messages that the object knows how to respond to. But it puts you into a different frame of mind. You start to think\nabout the name of an object, <code class=\"language-text\">Shape</code>, <code class=\"language-text\">Rectangle</code>, as opposed to an object which responds to the message <code class=\"language-text\">area</code>. Now, clearly you can write what basically I am\ncalling \"good\" OO code in C++, most of the time this devolves into templates and the newer concept of Concepts. However, in my experience, C++ is neither taught nor\npracticed this way. C++ is used like Java, and that is why they are often seen as competing technologies. Also, as a sidebar, clearly anything\ncan be done in any language, but I am talking about both what is natural in a language, what is intended/built-in, and how a language is actually used in practice. I\nlove C++ for certain low level programming tasks. I enjoy the static type checker, especially when it comes to type safe containers. But, I find that the benefits you\nget from these features really only shine when you are programming in the large, but at that point you end up with so many different people touching the code that\nyou end up a slave to what the language requires to get something to compile rather than really focusing on solving the problem at hand.</p>\n<h2>Interfaces / Protocols / Typeclasses</h2>\n<p>In a language like Ruby, where there are no formal type declarations and hence no static analysis, you are still coding against an interface between the classes you write.\nThis informal API driven style works in Ruby mostly by convention, and hence it only works with high quality, thoughtful engineers. If you have someone slapping things\ntogether, they are just going to add methods as they need them and move on. No static analysis means that it is up to the programmer to ensure that API changes propagate\nthroughout the codebase. Nonetheless, an interface is all that is really important when you are writing code. If you have objects in your system, all you really care\nabout is what can I tell them to do. What messages can I send between different objects. This is one notion that has been codified decently well in some languages, and\nhas been bolted on by some older languages. This is the notion of a Typeclass in Haskell, a Protocol in Objective-C, an Interface in Go, etc. Now at this point, the\nHaskell guys will be jumping up and down saying things like \"typeclasses in Haskell are only superficial similar to interfaces in Go\" and \"you really mean structural\nsubtyping, because Haskell typeclasses are so much more powerful\". (For a bit on Haskell and OOP in general check <a href=\"http://www.haskell.org/haskellwiki/OOP_vs_type_classes\">this out</a>)\nMy response to that is you are probably right, but it doesn't matter much day to day, because all\nthat I am referring to is a way to codify a set of messages that are allowed. The question becomes whether this is possible to do statically or whether it must happen\nat runtime. Go interfaces can most of the time be checked statically, Haskell has a much more powerful type system so it can do a shitload more at compile time.\nFor the purpose of writing code, what really matters is a clean way to define an interface. Objective-C has protocols which start to get a bit hairy because you have\nto explicitly qualify the fact that a class conforms to a given protocol. Go does this really nicely by handling this implicitly based on the functions that have\nbeen defined for a particular type. Long story short, the interface is the important piece about a type system that you really care about, so a good language must\nmake interfaces easy to handle, preferably statically. Ruby fails here, so do most other highly dynamic duck-typed languages. Objective-C kinda works here as long\nas you don't bend the rules too much. Haskell always wins these battles, but I find Go's approach to be quite pleasant, even if strictly less powerful.</p>\n<h2>Mixins vs Inheritance</h2>\n<p>One of the key issues with interfaces is how to implement a generic version of the functionality. How does one write code for the base case that is the same for most\nobjects that conform to that interface? Essentially, how does one write generic code? The traditional OO approach would be to define the interface through a base\nclass, put the generic version of the code in the base implementation, and then use inheritance to specialize those methods while maintaining the same API. What\nhappens when you want to inherit from multiple classes to build up your interface from a set of already defined interfaces? In C++ you can reach for multiple\ninheritance, usually in the form of some mix of interface inheritance and implementation inheritance by using a mix of public/private inheritance. This actually works\nalright if you know what you are doing. The alternative is templates which are the lifeblood of C++ generic programming. They are really quite nice when you get them\nright, but they have their own quirks and issues. In Objective-C, you either drop into Objective-C++ to use templates, or you use standard inheritance. Often times\nyou want to add a set of instance methods to a group of related classes, and have the interface to those instance methods be defined by a protocol. There just is no\neasy way to do this. Ruby gets this right with a feature that makes the language incredibly nice to work with, the mixin. I don't know enough about this, but I\nbelieve there is a notion like this in Javascript as well. This is one of the main features of Ruby that allow you to reuse code, define thin interfaces, and not\nget bogged down with inheritance. A language that forces you into inheritance to DRY up code is broken. The entire philosophy of OO is premised on using inheritance\nto define is-a relationships. This is completely broken when you are just using it to share code. In Objective-C, I usually end up writing service objects, or classes\nwhich are just a collection of static methods, and then use composition to delegate methods defined in a protocol to an inner object that is perhaps configurable.\nThis ends up with a similar consequence as the mixin, but it is significantly less clean and leads to unclear code as an object ends up being composed of too many\nother objects.</p>\n<h1>To be continued</h1>\n<p>I have a lot more to say on this subject, but I don't want to make this post take too long, and also I sometimes need motivation to keep writing. So I am going to push\na few of the sections onto another post. The next couple sections that I want to discuss are:</p>\n<ul>\n<li>Refactoring vs Building</li>\n<li>Static vs Dynamic</li>\n</ul>\n<p>I will hopefully return to this topic very shortly and finish up my ramblings on this subject. Briefly glancing at this, I don't think this was that informative,\nso I will probably also use the next post to summarize a bit and make some more definitive statements.</p>","frontmatter":{"title":"What's in a type?","date":"17 May 2014","categories":"code","tags":["go","code","ruby","erlang","types","objc"]},"timeToRead":8,"wordCount":{"words":2089},"fields":{"sha":"9a9b8cc9a846a5ab6c26cb187880f3092ad02345"},"parent":{"relativePath":"2014-05-17-whats-in-a-type.md"}}},"pageContext":{"slug":"/blog/2014-05-17-whats-in-a-type/"}},"staticQueryHashes":["3159585216","3192915761"],"slicesMap":{}}