{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2014-01-12-playing-with-haskell/","result":{"data":{"markdownRemark":{"html":"<p>Before I get in to the coding part of this post I figured I would talk a little\nbit about what is going on because I have not posted in a little over a week.\nNothing too crazy has happend lately, although we did go see one apartment\nplace, Lauren liked it a lot, I also liked it, so we are moving next weekend.\nWe are going to pay pretty close to the same rent (which is way too high still)\nbut get 2 bedrooms and 2 bathrooms instead of 1 bedroom and 1 bathroom. We will\nalso be in walking distance of Lauren's work which will dramatically change our\ncommuting situation. Right now we end up having to coordinate using our car and\nwhen we go to and from work because I am often lazy and don't feel like riding\nmy bike. This new situation will allow her to walk and me to walk to the train\nstation if I am feeling lazy, so no more annoying coordination. We will also be\ngetting tv again and legitimate internet which will be a huge win. The downside\nis that we have to go through the moving process which is always just terrible.\nWe are getting pretty good at it considering this will be each of our roughly\ntenth place. We went through all of our stuff today and threw out 10+ garbage\nbags worth of random crap and clothes we don't wear anymore. The troubling part\nbeing the place does not look that much different. It is amazing how easy it is\nto accumulate crap, I know I will continue to accumulate it most likely, but it\nis good to clean things up now and then. I will be more willing to do this type\nof cleaning in the future because it felt good to unburden myself from a lot of\njunk. Now, on to the code.</p>\n<p>I have been getting back into Haskell again recently and for whatever reason I\nlike it a lot more this time around. I have always been much happier coding in\nfunctional languages, but I have spent most of that time working with Erlang\nwhich is basically untyped whereas Haskell is strongly typed. I don't think I\nreally appreciated the benefits of such a full featured type system until I\nspent a lot of time working in Objective-C. If you have ever spent time trying\nto prevent shooting yourself in the foot in Obj-C then you know what I am\ntalking about.</p>\n<p>Interestingly enough I have been working on a side project that involves both\nlanguages. I have been prototyping the concept of generating Obj-C with Haskell\nto make a lot of the boilerplate that goes into creating an app less annoying,\nbut more importantly making it declarative and statically verified. Anyway, I\nhave been spending some time playing around with parsing in Haskell, which\nleads to <a href=\"http://legacy.cs.uu.nl/daan/parsec.html\">Parsec</a>. Just for fun, I wrote a little parser for JSON just\nto get my feet wet.</p>\n<p>I am going to walk through it because there is only a small amount of code\nwhich is pretty interesting. First the preamble because I hate reading code on\nblogs which isn't easy to get running.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token import-statement\"><span class=\"token keyword\">import</span> Control<span class=\"token punctuation\">.</span>Applicative <span class=\"token keyword\">hiding</span></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;|></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">many</span><span class=\"token punctuation\">)</span>\n<span class=\"token import-statement\"><span class=\"token keyword\">import</span> Text<span class=\"token punctuation\">.</span>ParserCombinators<span class=\"token punctuation\">.</span>Parsec</span>\n<span class=\"token import-statement\"><span class=\"token keyword\">import</span> Text<span class=\"token punctuation\">.</span>ParserCombinators<span class=\"token punctuation\">.</span>Parsec<span class=\"token punctuation\">.</span>Language</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">haskellDef</span><span class=\"token punctuation\">)</span>\n<span class=\"token import-statement\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">qualified</span> Text<span class=\"token punctuation\">.</span>ParserCombinators<span class=\"token punctuation\">.</span>Parsec<span class=\"token punctuation\">.</span>Token <span class=\"token keyword\">as</span> P</span>\n\n<span class=\"token hvariable\">lexer</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>makeTokenParser</span> <span class=\"token hvariable\">haskellDef</span>\n<span class=\"token hvariable\">brackets</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>brackets</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">braces</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>braces</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">stringLit</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>stringLiteral</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">naturalOrFloat</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>naturalOrFloat</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">commaSep</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>commaSep</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">symbol</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>symbol</span> <span class=\"token hvariable\">lexer</span>\n<span class=\"token hvariable\">colon</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">P<span class=\"token punctuation\">.</span>colon</span> <span class=\"token hvariable\">lexer</span></code></pre></div>\n<p>These are some pretty standard imports, and then we define some simple parsers\nat the top level of this module that we will use to build up the parser.</p>\n<p>The entry point into the parser we will call <code class=\"language-text\">json</code> and which will recognize\nthe two top level types that make up the json spec:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">json</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">json</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">object</span> <span class=\"token operator\">&lt;|></span> <span class=\"token hvariable\">array</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*</span> <span class=\"token hvariable\">eof</span></code></pre></div>\n<p>Okay so this makes a little less sense if you know what is going on here. We\nare defining a parser which returns an <code class=\"language-text\">Integer</code> because for fun I am going to\nmake this thing sum up all of the numbers that show up in the input. This is\njust because we have to do something meaningful, but I don't really feel like\ndoing too much more with it. So with that in mind, let's go through what is\ngoing on here. JSON is either an object or an array. We need the <code class=\"language-text\">&lt;* eof</code> to\nsay basically that we want to parse all of the input and fail if there is any\ntrailing characters that do not properly parse. So basically\n<code class=\"language-text\">{\"key\":1},[1,2,3]</code> should not parse as valid, but without the extra bit it\nwould parse just ignorning the <code class=\"language-text\">,[1,2,3]</code>. Ok well what is an object?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">object</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">object</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">summedListOfStuff</span> <span class=\"token hvariable\">braces</span> <span class=\"token hvariable\">keyValue</span> <span class=\"token operator\">&lt;?></span> <span class=\"token string\">\"object\"</span>\n\n<span class=\"token hvariable\">summedListOfStuff</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">CharParser</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">Integer</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">CharParser</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">Integer</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                  <span class=\"token operator\">-></span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n                  <span class=\"token operator\">-></span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">summedListOfStuff</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">v</span> <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">vs</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">commaSep</span> <span class=\"token operator\">$</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">many1</span> <span class=\"token hvariable\">v</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">sum</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">concat</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">vs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>An object is key-value pairs between a set of braces, and because we are trying\nto sum up the numbers we find we use an auxiliary function to create a parser\nthat does just that when given the outer delimeters and a parser. It turns out\nthat array is very similar</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">array</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">array</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">summedListOfStuff</span> <span class=\"token hvariable\">brackets</span> <span class=\"token hvariable\">value</span> <span class=\"token operator\">&lt;?></span> <span class=\"token string\">\"array\"</span></code></pre></div>\n<p>Basically the same thing just instead of braces we have brackets and instead of\nkey-value pairs we just have values. This highlights the declarative nature of\ncombinator parsers where you just describe what something is and out comes a\nparser that does what you want. So as long as we define what a key-value pair\nis and what a value is then we are done.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">keyValue</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">keyValue</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">stringLit</span> <span class=\"token operator\">>>=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">colon</span> <span class=\"token operator\">>>=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">value</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;?></span> <span class=\"token string\">\"key-value pair\"</span>\n\n<span class=\"token hvariable\">value</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Parser</span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">value</span> <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">try</span> <span class=\"token hvariable\">stringLit</span>\n    <span class=\"token builtin\">return</span> <span class=\"token number\">0</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">e</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">naturalOrFloat</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">i</span> <span class=\"token operator\">-></span> <span class=\"token builtin\">return</span> <span class=\"token hvariable\">i</span>\n      <span class=\"token constant\">Right</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">-></span> <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">truncate</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">symbol</span> <span class=\"token string\">\"true\"</span>\n    <span class=\"token builtin\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">symbol</span> <span class=\"token string\">\"false\"</span>\n    <span class=\"token builtin\">return</span> <span class=\"token number\">0</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">symbol</span> <span class=\"token string\">\"null\"</span>\n    <span class=\"token builtin\">return</span> <span class=\"token number\">0</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token hvariable\">try</span> <span class=\"token hvariable\">array</span>\n  <span class=\"token operator\">&lt;|></span> <span class=\"token hvariable\">object</span>\n  <span class=\"token operator\">&lt;?></span> <span class=\"token string\">\"value\"</span></code></pre></div>\n<p>So for key-value pairs I was playing around with using bind instead of the do\nsyntax, you can just ignore that. A key-value pair is a string literal followed\nby a colon followed by a value, pretty clear from the definition that is what\nis going on.</p>\n<p>Then what is a value? Well, it is a string, a number, an array, an object, or\none of the literals: <code class=\"language-text\">true</code>, <code class=\"language-text\">false</code>, or <code class=\"language-text\">null</code>. This is where we get the\nactual integers that we end up summing up. I decided to make strings, <code class=\"language-text\">false</code>,\nand <code class=\"language-text\">null</code> equal to zero, <code class=\"language-text\">true</code> equal to one, integers equal to themselves,\nand to truncate floats. In the end this allows us to reduce the whole JSON\nobject to a single integer.</p>\n<p>Technically this parser does not\nparse to the exact spec. For instance <code class=\"language-text\">stringLiteral</code> will not match strings with\nunicode code points of the form \\uXXXX directly in the string. This would not\nbe too difficult to fix but I don't particularly care for this toy. Also\nnaturalOrFloat does not exactly match the number type in the spec but again\nwhatever.</p>\n<p>This gets us to the following in GHCi:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">λ> parse json \"\" \"[1,2,3]\"\nRight 6\nλ> parse json \"\" \"{\\\"key\\\":[1,3,5],\\\"keyz\\\":[{\\\"arrKey\\\":10}, 1, 4],\\\"whoa\\\":null}\"\nRight 24\nλ> parse json \"\" \"{\\\"key\\\":1},{}\"\nLeft (line 1, column 10):\nunexpected ','\nexpecting end of input</code></pre></div>","frontmatter":{"title":"Playing with Haskell","date":"12 Jan 2014","categories":"code","tags":["haskell","moving"]},"timeToRead":5,"wordCount":{"words":1032},"fields":{"sha":"9a9b8cc9a846a5ab6c26cb187880f3092ad02345"},"parent":{"relativePath":"2014-01-12-playing-with-haskell.md"}}},"pageContext":{"slug":"/blog/2014-01-12-playing-with-haskell/"}},"staticQueryHashes":["3159585216","3192915761"],"slicesMap":{}}