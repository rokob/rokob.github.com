{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2014-06-02-swiftly-working/","result":{"data":{"markdownRemark":{"html":"<p>This post is my mind dump from a few minutes after \"Swift\" was announced. As I perused the <a href=\"https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11\">documentation</a>\nI made a few observations about this new language. After spending a little bit more time with it, I have some\nslightly different opinions, but most of these initial thoughts are still valid. I am not going to just put\nthese up here unedited, and then add a section at the bottom of further thoughts.</p>\n<h2>First Thoughts</h2>\n<p>Swift is pretty sick. It borrows some syntax from Go including types after names which has really started\nto grow on me, forced braces with conditionals and no parentheses required, and multiple return types.</p>\n<p>Type annotations must be explicitly marked as nullable which probably gives the compiler\na big boost by being able to use the fast path for message sends that avoid nil checks.</p>\n<p>String interpolation is HUGE, using Ruby for a while I can't believe people are not going\nnuts with <code class=\"language-text\">stringWithFormat:</code>.</p>\n<p>Switch statements that extend beyond simple integer types is amazing for different types of true\npattern matching. Still no pattern matching in function declarations which is what makes functional\nlanguages (Haskell, Erlang, ML, etc.) really shine, but still better switch statements are better for\nthe world. No Implicit Fallthrough in switch statements also, i.e. they fixed their \"goto fail;\" bug\nat the language level. Nice. Go also has this. Also assignments and where statements in case\nstatements is pretty nice.</p>\n<p>Generics.</p>\n<p>Array mutability is a bit broken: \"Immutability has a slightly different meaning for arrays, however.\nYou are still not allowed to perform any action that has the potential to change the size of an immutable\narray, but you are allowed to set a new value for an existing index in the array.\" I mean they go on to\nsay it provides optimizations, but calling it immutable and then saying you can mutate it is classic Apple.</p>\n<p>Ruby style range syntax, i.e. 1...theEnd, is a nice addition. Strings are enumerable by character\nwhich is also a nice convenience feature.</p>\n<p>Much nicer function syntax, including external/internal parameters, better closure syntax which\nmeans your functions that return functions no longer look like someone sat on your keyboard.</p>\n<p>Enums which have associated values which are basically really fancy unions. A dubious feature,\nconsidering their example uses QR codes.</p>\n<p>Sadly Swift still supports classes with inheritance. But there are now structs that look like classes\nbut are value types which don't have any reference counting, so much easier to have real value objects\nfloating around. Also, proper constructor/destructor semantics called initializer/deinitializer. You\ndon't return a value from the initializer like you do in objc, and the deinitializer is called before\ndealloc so you can have a consistent view of your object state. Wow.</p>\n<p>Builtin KVO, \"property observers\", seems like an odd way to go.</p>\n<p>Override the [] operator, who feels like writing a matrix class???</p>\n<p>Unowned references which are described as non-optional weak references are just unsafe_unretained, why\nfor the love of god? Also this whole section of the reference will be the cause of the most bugs people\nwrite. Two-Phase initialization combined with implicitly unwrapped optional references is just weird and\nvery error prone. But,</p>\n<p>Closure Capture Lists!!!</p>\n<p>The optional chaining support is pretty similar to some of the approaches to the <a href=\"https://github.com/bhb/maybe\">Maybe monad\nin Ruby</a>, it's a hard problem without biting the bullet and accepting that you really\nare dealing with monads. Swift seems to take the approach that optionality (Maybe) will be the only\nmonad you care about.</p>\n<p>Protocol conformance checks are much cleaner now: <code class=\"language-text\">dataSource?.incrementForCount?(count)</code> where\nincrementForCount is an optional method in a protocol that dataSource conforms to.</p>\n<p>Overall it seems like a huge leap forward from Objective-C, but not quite all the way to a truly\nfunctional language. Pragmatism and runtime constraints probably win out. The most glaringly obvious\nomission is anything related to making concurrency easier. Why would you make a new language today\nwithout thinking about concurrency? At least something like channels or actors, something plz.\nNo new imperative languages!</p>\n<h2>Later Thoughts</h2>\n<p>Some interesting features I found in the grammar defintion. For instance, you can override\noperators and even add your own, so this becomes possible:</p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\"><span class=\"token operator\">@</span>infix func <span class=\"token operator\">>>=</span><span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">:</span> Any<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">:</span> Any<span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> T <span class=\"token operator\">-></span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  var result <span class=\"token operator\">=</span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> m <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> y <span class=\"token keyword\">in</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      result<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">@</span>infix func <span class=\"token operator\">>></span><span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">:</span> Any<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">:</span> Any<span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> m <span class=\"token operator\">>>=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> K<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">in</span> b<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nfunc lift<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">:</span> Any<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\nfunc fail<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">:</span> Any<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>_s<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we have the implementation of the Monad typeclass for a generic array type in Swift.\nThe Tuple type I somehow glossed over almost completely on my first pass through, but it\nis actually pretty huge. It is what allows multiple return types which I saw initially,\nbut I didn't catch that it was a full blown type that basically gives you a fixed size\ncontainer with optional names for the values at the different positions. This is weird\nthat this exists because of the broken Array immutability because it makes me think that\nthe optimizations that exist for an immutable array is really just converting the object\nto be a mutable tuple.</p>\n<p>Where clauses in Generic type parameter lists is pretty huge for bringing real type\nsafe generic programming to iOS.</p>\n<p>The most important part of the language that I missed is the bit on attributes.\nThis allows for quite a bit of language annotations that everyone I know has wanted\nin iOS and Objective-C for a long time. For instance, being able to mark classes and\nmethods as final, and language support for lazy properties. These are pretty big deals.</p>\n<p>Another thing that I have found is missing from the documentation is a clear discussion\nof code visibility. If you create a new iOS app with the Swift templates in the new\nversion of Xcode, you will find that all of the classes your create are basically visible to everything in\nyour application. You don't have to import anything. This is terrible. It seems great\nfor a small project, but not being able to understand the dependency structure of\nyour project is pretty bad. I am assuming that there is something I am just missing,\nbut the docs are sparse on the topic of Modules. There is a construct, it just isn't\nreally clear what the deal is.</p>","frontmatter":{"title":"Swiftly Working on iOS","date":"02 Jun 2014","categories":"code","tags":["code","objc","swift"]},"timeToRead":4,"wordCount":{"words":1010},"fields":{"sha":"9a9b8cc9a846a5ab6c26cb187880f3092ad02345"},"parent":{"relativePath":"2014-06-02-swiftly-working.md"}}},"pageContext":{"slug":"/blog/2014-06-02-swiftly-working/"}},"staticQueryHashes":["3159585216","3192915761"],"slicesMap":{}}